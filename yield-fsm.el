;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; yield-fsm.el --- Finite State Machine for Resumable Operations -*-
;;; lexical-binding: t; -*-

;;; Commentary:
;;; This library provides a core Finite State Machine (FSM) designed for
;;; managing complex, resumable, sequential logic. It serves as the runtime
;;; engine for the `yield-generator.el` library, enabling cooperative
;;; multitasking by breaking operations into discrete, manageable steps.
;;;
;;; The FSM is a loop that transitions between a small number of states,
;;; such as `:step` (selecting the next operation), `:run-step` (executing it),
;;; and `:advance` (moving to the next index). This state-driven loop is the
;;; heart of the generator's execution model.
;;;
;;; The FSM executes a defined sequence of "steps", where each step is
;;; a thunk (a zero-argument function) created by the `yield-cpm.el`
;;; compiler. It can be paused at any point (i.e., when a step yields a value)
;;; and resumed later from that exact point, retaining its internal state,
;;; because all state is held within the `yield-fsm` struct instance.

;;; Code:

(require 'cl-lib)
(require 'dash)
(require 'ht)
(require 's)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Constants

;; These constants define the protocol for communication between the FSM and
;; the calling code, as well as between FSM steps themselves. Using `defconst`
;; ensures these symbols are consistently defined.

(defconst yield--yield-throw-tag 'yield-fsm-yield
  "Tag used for non-local exits when a generator yields a value.
This `throw` allows the FSM to immediately suspend its execution loop and
return control to the `yield-fsm-run` function, which then returns the
yielded value to the user.")

(defconst yield--done-throw-tag 'yield-fsm-finished
  "Tag used for non-local exits when a generator completes its execution.
This allows the error handling logic to cleanly exit the FSM loop upon a
non-recoverable error.")

(defconst yield--yield-status-key :yield
  "Status key indicating the FSM yielded a value.")

(defconst yield--await-external-status-key :await-external
  "Status key indicating the FSM yielded for an external async operation.")

(defconst yield--done-status-key :done
  "Status key indicating the FSM completed successfully.")

(defconst yield--error-status-key :error
  "Status key indicating the FSM terminated due to an error.")

(defconst yield--delegating-status-key :delegating
  "Status key indicating the FSM is currently delegating to a sub-generator.")

(defconst yield--jump-status-key :jump
  "Instruction key returned by a step to command the FSM to jump to a
different, named step instead of proceeding to the next one in the sequence.
This is used to implement control flow like loops and conditionals.")

(defconst yield--value-key :value
  "Plist key for the yielded or returned value in status plists.")

(defconst yield--fsm-object-key :fsm
  "Plist key for the FSM object itself when a yield occurs.")

(defconst yield--error-object-key :error-object
  "Plist key for the error object when an FSM terminates due to an error.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; FSM Struct Definition

(cl-defstruct (yield-fsm (:constructor %%make-yield-fsm) (:copier nil))
  "A resumable Finite State Machine for orchestrating step-based logic.

Instances of this struct represent a single running generator instance.
All state required for the generator to suspend and resume is stored here,
making the generator's lambda function a stateful closure over this struct.

Do not construct directly; use `yield-fsm-new`.

Fields:
  state (symbol): The current state of the FSM's execution loop, e.g.,
                  `:init`, `:run-step`, `:error`.
  phase (symbol): The current execution phase, `:normal` or `:finally`, to
                  distinguish between main logic and cleanup logic.
  steps (vector): A vector of step plists for the normal execution phase,
                  generated by the CPM.
  finally-steps (vector): A vector of step plists for the finalization phase.
  index (integer): The current program counter, an index into the `steps` vector.
  finally-index (integer): The program counter for the `finally-steps` vector.
  results (hash-table): A table to store results from steps (if needed).
  finally-results (hash-table): A table to store results from finally steps.
  context: An arbitrary object for passing data between steps, typically the
           `coroutine-ctx` instance.
  retries (integer): The default maximum number of retries for failing steps.
  retry-count (integer): The current retry count for the active step.
  step: The currently executing step plist from the `steps` vector.
  step-error: The error object if the last step failed.
  error-handler (function): A function to call to attempt recovery from an
                            error, e.g. `(lambda (fsm error step) ...)`.
  yielded-value: The value most recently yielded by the FSM.
  was-yielded (boolean): A flag set to `t` when the FSM is paused by a yield,
                         used by `resume!` to validate it can run.
  resuming-value: The value passed from `next!` into a resumed generator. This
                  becomes the return value of the `yield!` expression.
  completed-status (symbol): The final completion status (`:done` or `:error`).
  active-delegate: A sub-generator instance if the FSM is delegating via
                   `yield-from!`.
  step-result: The raw return value of the last executed step thunk."
  (state :init :type symbol)
  (phase :normal :type symbol)
  (steps nil :type vector)
  (finally-steps nil :type vector)
  (index 0 :type integer)
  (finally-index 0 :type integer)
  (results (ht-create) :type hash-table)
  (finally-results (ht-create) :type hash-table)
  context
  (retries 0 :type integer)
  (retry-count 0 :type integer)
  step
  step-error
  (yielded-value nil :type t)
  error-handler
  (was-yielded nil :type boolean)
  resuming-value
  completed-status
  active-delegate
  step-result)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Internal Helper Functions

(defun yield-fsm--finalize-fsm (fsm status &optional error-obj)
  "Finalize the FSM's completion status and return the done/error plist.
This function sets the FSM's final status and prepares the plist that will be
the ultimate return value of the `yield-fsm-run` loop.

Arguments:
  FSM (yield-fsm): The `yield-fsm` instance to finalize.
  STATUS (symbol): The final status symbol, either `:done` or `:error`.
  ERROR-OBJ: The error object if STATUS is `:error`.

Results:
  A plist representing the final status (`:done ...` or `:error ...`)."
  (setf (yield-fsm-completed-status fsm) status)
  (if (eq status yield--error-status-key)
      `(,status t ,yield--error-object-key ,error-obj)
    `(,status t ,yield--value-key ,(yield-fsm-step-result fsm))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; FSM Dispatcher Helpers

;; The FSM execution is a `while` loop in `yield-fsm-run`. Each iteration of
;; the loop dispatches to one of these helper functions based on the FSM's
;; current `state` symbol. This creates a clean, state-driven cycle.

(defun yield-fsm--dispatch-init (fsm)
  "Handles the `:init` state by resetting counters and moving to `:step`."
  (setf (yield-fsm-retry-count fsm) 0)
  (setf (yield-fsm-state fsm) :step))

(defun yield-fsm--dispatch-step-selection (fsm)
  "Handles the `:step` state by selecting the next step to run.
This function acts as the FSM's instruction fetch stage. It uses the current
`index` (program counter) to get the next step from the `steps` vector.
If there are no more steps, it either transitions to the `:finally` phase or
signals that the FSM is done."
  (let* ((phase (yield-fsm-phase fsm))
         (steps (if (eq phase :normal)
                    (yield-fsm-steps fsm)
                  (yield-fsm-finally-steps fsm)))
         (index (if (eq phase :normal)
                    (yield-fsm-index fsm)
                  (yield-fsm-finally-index fsm))))
    (if (and steps (< index (length steps)))
        ;; If more steps remain in the current phase, select the next one.
        (progn
          (setf (yield-fsm-step fsm) (aref steps index))
          (setf (yield-fsm-state fsm) :run-step)
          nil) ; Return nil to indicate the `yield-fsm-run` loop should continue.
      ;; No more steps in the current phase.
      (if (eq phase :normal)
          (if (yield-fsm-finally-steps fsm)
              ;; Normal phase is done, transition to the :finally phase.
              (progn
                (setf (yield-fsm-phase fsm) :finally)
                (setf (yield-fsm-state fsm) :init)
                nil) ; Loop continues.
            ;; No :finally steps, so we are done.
            `(,yield--done-status-key t))
        ;; :finally phase is done, so we are finished.
        `(,yield--done-status-key t)))))

(defun yield-fsm--dispatch-run-step (fsm)
  "Handles the `:run-step` state by executing the current step's thunk.
This is the core execution point. It calls the step's zero-argument lambda
and then interprets the result. The result can be a yielded value, a jump
command, or a normal expression value."
  (let (thunk-result thunk-error)
    ;; Execute the thunk within a `condition-case` to catch any Lisp errors.
    (condition-case err
        (let* ((step (yield-fsm-step fsm))
               (thunk (plist-get step :thunk)))
          (when (yield-fsm-was-yielded fsm)
            (setf (yield-fsm-was-yielded fsm) nil)
            (setf (yield-fsm-resuming-value fsm) nil))
          (setq thunk-result (funcall thunk)))
      (error (setq thunk-error err)))

    (if thunk-error
        (progn
          (setf (yield-fsm-step-error fsm) thunk-error)
          (setf (yield-fsm-state fsm) :error)
          nil)
      (pcase thunk-result
        ;; The step is delegating to a sub-generator.
        (`(:yield-from ,delegate)
         (unless (functionp delegate)
           (error "Delegate object is not a function: %S" delegate))
         (if (eq (yield-fsm-phase fsm) :normal)
             (cl-incf (yield-fsm-index fsm))
           (cl-incf (yield-fsm-finally-index fsm)))
         (setf (yield-fsm-active-delegate fsm) delegate)
         (setf (yield-fsm-state fsm) :delegating)
         `(,yield--delegating-status-key t))

        ;; The step commanded a jump to another named step.
        (`(:jump ,step-name . ,result-value)
         (setf (yield-fsm-step-result fsm) result-value)
         (let ((jump-target-index
                (cl-position-if (lambda (step)
                                  (eq (plist-get step :name) step-name))
                                (yield-fsm-steps fsm))))
           (unless jump-target-index
             (error "FSM Jump target '%S' not found!" step-name))
           (setf (yield-fsm-index fsm) jump-target-index)
           (setf (yield-fsm-state fsm) :step)) ; Go back to selection state.
         nil)

        ;; The step yielded a value or is done.
        (`(,tag ,val)
         (if (memq tag `(,yield--yield-status-key ,yield--await-external-status-key))
             ;; This is a yield. Pause execution and return to the caller.
             (progn
               (setf (yield-fsm-yielded-value fsm) val)
               (setf (yield-fsm-state fsm) :advance)
               (throw yield--yield-throw-tag
                      `(,tag t ,yield--value-key ,val ,yield--fsm-object-key ,fsm)))
           ;; This is a normal completion or other status.
           (setf (yield-fsm-step-result fsm) val)
           (setf (yield-fsm-state fsm) :advance)
           thunk-result))

        ;; The step returned a normal value.
        (_
         (setf (yield-fsm-step-result fsm) thunk-result)
         (setf (yield-fsm-state fsm) :advance)
         nil)))))

(defun yield-fsm--dispatch-advance (fsm)
  "Handles the `:advance` state after a step completes successfully.
This function is responsible for incrementing the step index (program counter)
to move execution to the next instruction in the sequence."
  (if (eq (yield-fsm-phase fsm) :normal)
      (cl-incf (yield-fsm-index fsm))
    (cl-incf (yield-fsm-finally-index fsm)))

  (when (yield-fsm-was-yielded fsm)
    (setf (yield-fsm-step-result fsm) (yield-fsm-resuming-value fsm))
    (setf (yield-fsm-was-yielded fsm) nil)
    (setf (yield-fsm-resuming-value fsm) nil))

  (setf (yield-fsm-retry-count fsm) 0)
  (setf (yield-fsm-state fsm) :step))

(defun yield-fsm--dispatch-error (fsm)
  "Handles the `:error` state, performing retries or finalization."
  (let* ((max-retries
          (or (plist-get (yield-fsm-step fsm) :retries)
              (yield-fsm-retries fsm))))
    (if (< (yield-fsm-retry-count fsm) max-retries)
        ;; If we have retries left, increment the count and go back to :run-step.
        (progn
          (cl-incf (yield-fsm-retry-count fsm))
          (setf (yield-fsm-state fsm) :run-step)
          nil)
      ;; No retries left. Check for an on-error handler or finalize.
      (if (and (eq (yield-fsm-phase fsm) :normal)
               (yield-fsm-error-handler fsm)
               (funcall (yield-fsm-error-handler fsm)
                        fsm
                        (yield-fsm-step-error fsm)
                        (yield-fsm-step fsm)))
          ;; The error handler succeeded; move to the :finally phase.
          (progn
            (setf (yield-fsm-phase fsm) :finally)
            (setf (yield-fsm-state fsm) :init)
            nil)
        ;; No handler or handler failed; terminate the FSM.
        (throw yield--done-throw-tag
               (yield-fsm--finalize-fsm fsm yield--error-status-key
                                        (yield-fsm-step-error fsm)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Public API

(defun yield-fsm-new (state steps &rest options)
  "Create a new `yield-fsm` instance.

Arguments:
  STATE (symbol): The initial state of the FSM (e.g., `:init`).
  STEPS (vector): A vector of FSM step plists to be executed.
  OPTIONS (plist): Additional configuration options:
    :context      - Arbitrary data accessible via `yield-fsm-context`.
    :retries      - Default max retries for failing steps (default 0).
    :on-error     - A function `(fsm error step)` to attempt recovery.
    :finally      - A list of step plists for a guaranteed cleanup phase.

Results:
  A new `yield-fsm` struct instance."
  (%%make-yield-fsm
   :state state
   :steps (vconcat steps)
   :context (plist-get options :context)
   :retries (or (plist-get options :retries) 0)
   :error-handler (plist-get options :on-error)
   :finally-steps (when-let ((fs (plist-get options :finally)))
                    (vconcat fs))))

(defun yield-fsm-run (fsm)
  "Run the FSM from its current state until it yields, errors, or completes.
This function contains the main execution loop of the FSM.

Arguments:
  FSM (yield-fsm): The `yield-fsm` instance to run.

Results:
  A status plist, e.g., `(:yield t :value VALUE)`, `(:done t ...)`."
  (cl-block yield-fsm-run-block
    (let (caught-value-from-yield-catch)
      (setf (yield-fsm-yielded-value fsm) nil)
      ;; This `catch` is what allows a `yield!` deep within a step to
      ;; immediately suspend the entire FSM loop.
      (setq caught-value-from-yield-catch
       (catch yield--yield-throw-tag
         (while t
           (when (yield-fsm-completed-status fsm)
             (cl-return-from yield-fsm-run-block
               (yield-fsm--finalize-fsm fsm
                                        (yield-fsm-completed-status fsm)
                                        (yield-fsm-step-error fsm))))

           (pcase (yield-fsm-state fsm)
             (:init     (yield-fsm--dispatch-init fsm))
             (:step     (let ((result (yield-fsm--dispatch-step-selection fsm)))
                          (when result
                            (cl-return-from yield-fsm-run-block
                              (yield-fsm--finalize-fsm fsm (car result)
                               (plist-get result yield--error-object-key))))))
             (:run-step (let ((result (yield-fsm--dispatch-run-step fsm)))
                          (when result
                            (cond
                             ((eq (car result) yield--done-status-key)
                              (cl-return-from yield-fsm-run-block
                                (yield-fsm--finalize-fsm
                                 fsm yield--done-status-key
                                 (or (plist-get result yield--value-key)
                                     (yield-fsm-step-result fsm)))))
                             ((eq (car result) yield--error-status-key)
                              (cl-return-from yield-fsm-run-block
                                (yield-fsm--finalize-fsm
                                 fsm (car result)
                                 (plist-get result yield--error-object-key))))
                             (t
                              (cl-return-from yield-fsm-run-block result))))))
             (:advance  (yield-fsm--dispatch-advance fsm))
             (:error    (let ((result (yield-fsm--dispatch-error fsm)))
                          (when result
                            (cl-return-from yield-fsm-run-block result))))
             (_ (error "FSM: Unknown state: %S" (yield-fsm-state fsm)))))))
    caught-value-from-yield-catch)))

(defun yield-fsm-resume (fsm value)
  "Resume execution of a yielded FSM, sending VALUE back to the generator.

Arguments:
  FSM (yield-fsm): The `yield-fsm` instance to resume.
  VALUE: The value to send back. This becomes the return value of the `yield!`
         expression that paused the generator.

Results:
  A status list as described in `yield-fsm-run`."
  (unless (yield-fsm-p fsm)
    (error "Not a yield-fsm struct: %S" fsm))
  ;; A yield must have occurred for resume to be valid.
  (unless (yield-fsm-was-yielded fsm)
    (error "FSM is not in a yielded state and cannot be resumed."))

  ;; Store the value that will be sent into the generator.
  (setf (yield-fsm-resuming-value fsm) value)

  ;; Re-enter the FSM's execution loop.
  (yield-fsm-run fsm))

(provide 'yield-fsm)
;;; yield-fsm.el ends here